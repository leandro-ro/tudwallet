# Allow Java modules to be imported
import jpype.imports
from jpype import JString, JPackage, JArray

# Start JVM with Java types on return
jpype.startJVM("-ea", classpath=['lib/*'], convertStrings=False)

# import the Java modules
from com.ewallet.field import ColdWallet
from com.ewallet.field import HotWallet
from com.ewallet.field.util import SECP
from com.ewallet.field.util import EllipticCurvePoint
from com.ewallet.field.util import PublicKey
from com.trident.crypto.field.element import FiniteFieldElementFactory


class ColdWalletWrapper:
    """Wraps the underlying (java) cold wallet into python"""

    def __init__(self, spec=SECP.SECP256K1, hash_algorithm="SHA-256"):
        """
        Instantiate an java cold wallet object.

        :param spec: specifies the elliptic curve (SECP256K1 for Ethereum)
        :param hash_algorithm: specifies the hash function (SHA-256 for Ethereum)
        """
        self.cold_wallet = ColdWallet(spec, hash_algorithm)

    def master_gen(self):
        """
        Generate a master key pair

        :return: a new master key pair
        """
        return self.cold_wallet.MasterGen()

    def sk_derive(self, master_sk, id, state):
        """
        Derives a new session secret key based on the given parameters

        :param master_sk: the master secret key (generated by master_gen())
        :param id: specifies the id (must be > than earlier used IDs)
        :param state: specifies the current state
        :return: a derived session secret key
        """
        return self.cold_wallet.SKDerive(master_sk, id, state)

    def pk_derive(self, master_pk, id, state):
        """
        Derives a new session public key based on the given parameters

        :param master_pk: the master public key (generated by master_gen())
        :param id: specifies the id (must be > than earlier used IDs)
        :param state: specifies the current state
        :return: a derived session public key
        """
        return self.cold_wallet.PKDerive(master_pk, id, state)

    def sign(self, msg, secret_key, public_key):
        """
        Generates a ECDSA signature for the given message based on the given key pair

        :param msg: a message
        :param secret_key: a session secret key
        :param public_key: a session public key
        :return: a ECDSA signature
        """
        return self.cold_wallet.Sign(msg, secret_key, public_key)


class HotWalletWrapper:
    """Wraps the underlying (java) hot wallet into python"""

    def __init__(self, spec=SECP.SECP256K1, hash_algorithm="SHA-256"):
        """
        Instantiate an java hot wallet object.

        :param spec: specifies the elliptic curve (SECP256K1 for Ethereum)
        :param hash_algorithm: specifies the hash function (SHA-256 for Ethereum)
        """
        self.hot_wallet = HotWallet(spec, hash_algorithm)

    def pk_derive(self, master_pk, id, state):
        """
        Derives a new session public key based on the given parameters

        :param master_pk: the master public key (generated by master_gen())
        :param id: specifies the id (must be > than earlier used IDs)
        :param state: specifies the current state
        :return: a derived session public key
        """
        return self.hot_wallet.PKDerive(master_pk, id, state)

    def verify(self, msg, public_key, signature):
        """
        Verifies a ECDSA signature for the given message and public key

        :param msg: a message
        :param public_key: a public key
        :param signature: a signature
        :return: True if the signature valid, False if not
        """
        return self.hot_wallet.verify(msg, public_key, signature)


# (Not in utils file because JVM needed)
def create_elliptic_curve_point(x, y):
    """
    Converts python coordinates to a java elliptic curve point

    :param x: x coordinate (python type)
    :param y: y coordinate (python type)
    :return: the coordinates as EllipticCurvePoint (java type/class)
    """
    factory = FiniteFieldElementFactory()
    converted_x = factory.createFrom(jpype.java.math.BigInteger(x))
    converted_y = factory.createFrom(jpype.java.math.BigInteger(y))

    return EllipticCurvePoint.create(converted_x, converted_y)


def hex_to_java_biginteger(hex_string):
    """
    Converts a python hexadecimal string to a BigInteger in java

    :param hex_string: hexadecimal string
    :return: the hex_string as BigInteger (java type/class)
    """
    return jpype.java.math.BigInteger(str(int(hex_string, 0)))


def to_jstring_in_bytes(msg: str):
    """
    Converts a python string to a JString[] in java

    :param msg: message
    :return: the message as JString[] (java type/class)
    """
    return JString(msg).getBytes("utf-8")


def _recover_state_from_list(data: list):
    """
    Recovers a state from its python list representation

    :param data: the state as a list
    :return: the state as JArray (java type/class)
    """
    converted = JArray(jpype.java.lang.Byte, 1)(len(data))
    counter = 0
    for item in data:
        if item <= 0:
            item = JString("-#" + str(hex(item * -1)).replace("0x", ""))
        else:
            item = JString(str(hex(item)))
        converted[counter] = jpype.java.lang.Byte.decode(item)
        counter += 1
    translate = JPackage('org').apache.commons.lang.ArrayUtils
    converted = translate.toPrimitive(converted)
    return converted


def coords_to_java_public_key(x, y, raw_state: list):
    """
    Recovers a java PublicKey from ECDSA coordinates and state

    :param x: x coordinate
    :param y: y coordinate
    :param raw_state: state as list of bytes
    :return: PublicKey (java type/class)
    """
    curve_point = create_elliptic_curve_point(str(int(x, 0)), str(int(y, 0)))
    byte_array = _recover_state_from_list(raw_state)
    return PublicKey(curve_point, byte_array)
